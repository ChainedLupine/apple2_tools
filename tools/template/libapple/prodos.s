; ProDOS routines (implementation)

.scope ProDOS

.segment "CODE_ROM_H"

.include "prodos-defs.inc"

.global RAMDISK_DISCONNECT, RAMDISK_RECONNECT

RAMDISK_DISCONNECT:
			PHP             ; SAVE STATUS AND
			SEI             ; MAKE SURE INTERRUPTS ARE OFF!
		
			; FIRST THING TO DO IS TO SEE IF THERE IS A /RAM TO DISCONNECT!
		
			LDA MACHID            ; LOAD THE MACHINE ID BYTE
			AND #$30              ; TO CHECK FOR A 128k SYSTEM
			CMP #$30              ; IS IT 128k?
			BNE @DONE              ; IF NOT THEN BRANCH SINCE NO /RAM!
 
			LDA RAMSLOT           ; IT IS 128K; IS A DEVICE THERE?
			CMP NODEV             ; COMPARE WITH LOW BYTE OF NODEV
			BNE @CONT              ; BRANCH IF NOT EQUAL, DEVICE IS CONNECTED
			LDA RAMSLOT+1         ; CHECK HI BYTE FOR MATCH
			CMP NODEV+1           ; ARE WE CONNECTED?
			BEQ @DONE              ; BRANCH, NO WORK TO DO; DEVICE NOT THERE
		
		; AT THIS POINT /RAM (OR SOME OTHER DEVICE) IS CONNECTED IN
		; THE SLOT 3, DRIVE 2 VECTOR.  NOW WE MUST GO THRU THE DEVICE
		; LIST AND FIND THE SLOT 3, DRIVE 2 UNIT NUMBER OF /RAM ($BF).
		; THE ACTUAL UNIT NUMBERS, (THAT IS TO SAY 'DEVICES') THAT WILL
		; BE REMOVED WILL BE $BF, $BB, $B7, $B3.  /RAM'S DEVICE NUMBER
		; IS $BF.  THUS THIS CONVENTION WILL ALLOW OTHER DEVICES THAT
		; DO NOT NECESSARILY RESEMBLE (OR IN FACT, ARE COMPLETELY DIFFERENT
		; FROM) /RAM TO REMAIN INTACT IN THE SYSTEM.
		
	@CONT: 	LDY DEVCNT        	  ; GET THE NUMBER OF DEVICES ONLINE	
	@LOOP: 	LDA DEVLST,Y      	  ; START LOOKING FOR /RAM OR FACSIMILE
			AND #$F3              ; LOOKING FOR $BF, $BB, $B7, $B3
			CMP #$B3              ; IS DEVICE NUMBER IN {$BF,$BB,$B7,$B3}?
			BEQ @FOUND            ; BRANCH IF FOUND..
			DEY                   ; OTHERWISE CHECK OUT THE NEXT UNIT #.
			BPL @LOOP             ; BRANCH UNLESS YOU'VE RUN OUT OF UNITS.
			BMI @DONE             ; SINCE YOU HAVE RUN OUT OF UNITS TO
	@FOUND:	LDA DEVLST,Y     	  ; GET THE ORIGINAL UNIT NUMBER BACK
			STA RAMUNITID         ; AND SAVE IT OFF FOR LATER RESTORATION.		
  
		; NOW WE MUST REMOVE THE UNIT FROM THE DEVICE LIST BY BUBBLING
		; UP THE TRAILING UNITS.
	@GETLP:	LDA DEVLST+1,Y 		  ; GET THE NEXT UNIT NUMBER
			STA DEVLST,Y          ; AND MOVE IT UP.
			BEQ @EXIT             ; BRANCH WHEN DONE(ZEROS TRAIL THE DEVLST)
			INY                   ; CONTINUE TO THE NEXT UNIT NUMBER...
			BNE @GETLP            ; BRANCH ALWAYS.
	@EXIT:	LDA RAMSLOT      	  ; SAVE SLOT 3, DRIVE 2 DEVICE ADDRESS.
			STA RAM_ADDR          ; SAVE OFF LOW BYTE OF /RAM DRIVER ADDRESS
			LDA RAMSLOT+1         ; SAVE OFF HI BYTE
			STA RAM_ADDR+1        ;
			
			LDA NODEV            ; FINALLY COPY THE 'NO DEVICE CONNECTED'
			STA RAMSLOT          ; INTO THE SLOT 3, DRIVE 2 VECTOR AND
			LDA NODEV+1          ;
			STA RAMSLOT+1        ;
			DEC DEVCNT           ; DECREMENT THE DEVICE COUNT.  
	@DONE:	PLP              	 ; RESTORE STATUS
			CLI
			RTS

RAMDISK_RECONNECT:			
			PHP              	  ; SAVE STATUS
			SEI                   ; AND MAKE SURE INTERRUPTS ARE OFF!
 
			LDY DEVCNT            ; GET THE NUMBER OF DEVICES - 1.
	@LOOP1:	LDA DEVLST,Y     	  ; LOAD THE UNIT NUMBER
			AND #$F0              ; CHECK FOR SLOT 3, DRIVE 2 UNIT.
			CMP #$B0              ; IS IT THE SLOT 3, DRIVE 2 UNIT?
			BEQ @DONE1            ; IF SO BRANCH.
			DEY                   ; OTHERWISE SEARCH ON...
			BPL @LOOP1            ; LOOP UNTIL DEVLST SEARCH IS COMPLETED
			LDA RAM_ADDR          ; RESTORE THE DEVICE DRIVER ADDRESS
			STA RAMSLOT           ; LOW BYTE..
			LDA RAM_ADDR+1        ; NOW THE
			STA RAMSLOT+1         ; HI BYTE.
			INC DEVCNT            ; AFTER INSTALLING DEVICE, INC DEVICE COUNT
			LDY DEVCNT            ; USE Y FOR LOOP COUNTER..
	@LOOP2:	LDA DEVLST-1,Y   	  ; BUBBLE DOWN THE ENTRIES IN DEVICE LIST
			STA DEVLST,Y          ;
			DEY                   ; NEXT
			BNE @LOOP2            ; LOOP UNTIL ALL ENTRIES MOVED DOWN.
			
		; NOW SET UP A /RAM FORMAT REQUEST
 
			LDA #3                ; LOAD ACC WITH FORMAT REQUEST NUMBER.
			STA $42               ; STORE REQUEST NUMBER IN PROPER PLACE.
			
			LDA RAMUNITID         ; RESTORE THE DEVICE
			STA DEVLST            ; UNIT NUMBER IN THE DEVICE LIST
			AND #$F0              ; STRIP THE DEVICE ID (ZERO LOW NIBBLE)
			STA $43               ; AND STORE THE UNIT NUMBER IN $43.
 
			LDA #$00              ; LOAD LOW BYTE OF BUFFER POINTER
			STA $44               ; AND STORE IT.
			LDA #$20              ; LOAD HI BYTE OF BUFFER POINTER
			STA $45               ; AND STORE IT.
 
			LDA $C08B             ; READ & WRITE ENABLE
			LDA $C08B             ; THE LANGUAGE CARD WITH BANK 1 ON.
 
		; NOTE HOW THE DRIVER IS CALLED.  YOU JSR TO AN INDIRECT JMP SO
		; CONTROL IS RETURNED BY THE DRIVER TO THE INSTRUCTION AFTER THE JSR.
 
			JSR @DRIVER            ; NOW LET DRIVER CARRY OUT CALL.
			BIT $C082              ; NOW PUT ROM BACK ON LINE.
 
			BCC @DONE1             ; IF THE CARRY IS CLEAR --> NO ERROR
			JSR @ERROR             ; GO PROCESS THE ERROR
 
	@DONE1:	PLP              	; RESTORE STATUS
			CLI
			RTS                 ; THAT'S ALL
 
	@DRIVER:	
			JMP (RAMSLOT)   	; CALL THE /RAM DRIVER
 
	@ERROR:	BRK              	; YOUR ERROR HANDLER CODE WOULD GO HERE
			CLI
			RTS
			
.segment "DATA_H"
	RAM_ADDR: 	.word $0000      ; STORE THE DEVICE DRIVER ADDRESS HERE
	RAMUNITID: 	.byte $00     	; STORE THE DEVICE'S UNIT NUMBER HERE	


.endscope

